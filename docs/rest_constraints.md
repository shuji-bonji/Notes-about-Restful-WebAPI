# REST制約

## RESTfulとは

RESTで求められている原則に従っていること

## RESTとは

**RE**presentational **S**tate **T**ransfer  
(分散型システムにおける設計原則群)

## REST原則
- null スタート
- クライアント／サーバ
- ステートレス
- キャッシュ制御
- 統一インターフェース
- 階層化システム
- コードオンデマンド

## クライアント／サーバー

### 画面(UI)とデータで関心ごとを分離

```
  UI:画面(UI)           データ

             リクエスト
クライアント   ----------> サーバー
           <----------
             レスポンス                         
```

### クライアント側がトリガー、サーバ側は受け身

```
  トリガー                受け身

             リクエスト
クライアント   ----------> サーバー
           <----------
             レスポンス                         
```

## 階層化システム

階層型アーキテクチャ

```
            (コンポーネント)
[ユーザー] === [Web] ------- [AP] ------- [DB]

```
```
            (コンポーネント)
[ユーザー] === [Web] ------- [AP] ------- [DB]
               |      ×      |      ×      |
             [Web] ------- [AP] ------- [DB]
               |      ×      |      ×      |
             [Web] ------- [AP] ------- [DB]

```

### 階層化システムのメリット

各シスステム（コンポーネント）に役割を決めて独立させることで、進化と再利用あ促進できる

### 階層化システムのデメリット

データ処理にオーバーヘッドが発生（キャッシュを利用するなどの改善は行える）


## コードオンデマンド

クライアントコードをダウンロードして実行できる

例）レスポンスにJavaScriptなどを送信し、そのコードをブラウザで実行する

### コードオンデマンドのメリット
- リリース後にクライアントコードを更新でき、機能追加できる
- サーバの負荷が下がる（クライアント側に処理が委譲できるため）

### コードオンデマンドのデメリット
- 評価環境が複雑になる


## 統一インターフェース


### 4つの制限
- リソースの識別
- 表現を用いたリソース操作
- 自己記述メッセージ
- アプリケーション状態エンジンとしてのハイパーメディア（HATEOAS）

### リソースの識別

URIを用いてサーバに保存されたデータを識別すること。  
（URIには動作は含まない）

- リソース:  
名前が付けられるあらゆるもの。  
サーバー側に保持されるデータ（ドキュメント、画像、情報、サービス...)  
また、抽象的な定義も含める（「ある断面」: 4月1日の天気、「最新」（今日の天気）etc...)
- URI:  
リソースを識別するもの

### 表現を用いたリソース操作

表現（断面情報）を利用してサーバー上のデータを操作すること

- 表現:  
リソース（サーバー位保存されたデータ）のある断面、クライアントへ返されるレスポンスやサーバへPOSTするデータを指し示す。

また、クライアントからサーバへ編集リクエストをする際、認証情報などの追加情報（メタデータ）を付与します。

### 自己記述メッセージ

メッセージ内容がなんであるか？ヘッダーに記述されていること

- 自己記述:  
データ自身がデータの中身を説明している。
- メッサージ:  
サーバへリクエストするデータ、クライアントにレスポンスするデータ



### アプリケーション状態エンジンとしてのハイパーメディア（HATEOAS）

*H*ypermedia *a*s *t*he *E*ngine *o*f *A*pplication *S*tate


レスポンスに現在の状態を踏まえて関連するハイパーリンクが含まれている

例)  
検索結果ページにおける「次のページ」

```json
{
	message: "Hello World",
	links: [
		{name: "next", url: "http://sample.com/message/3"},
		{name: "prev", url: "http://sample.com/message/5"},
	]
}
```


### 統一インターフェースのメリット

- システムアーキテクチャ全体が簡素化されてわかりやすくなる。
- 提供するサービスに集中でき、独自の進化ができる
- 異なるブラウザでも同じような画面を表示できる

### 統一インターフェースのデメリット

- 標準化によって効率が犠牲になる


## ステートレス

サーバーはリクエストだけでコンテキストを理解できる

- サーバーに保存されたコンテキスト情報は使わない（サーバーセッションは使わない）
- 状態はクライアント上に保存される（リクエストに全て含める）

リクエストに状態情報を含むことで、リクエストが独立する

### ステートフルとステートレス

ハンバーガーショップでハンバーガーを各ケース

#### ステートフル
前の会話の状態を保持したままやり取りされる。各会話毎に見ると内容が把握しづらい

1. <店員>: ご注文どうぞ
2. 【客】: お値打ちセット
3. <店員>: バーガー、ドリンクはどれを選択されますか？
4. 【客】: チーズバーガー
5. 【客】: ジンジャーエール


#### ステートレス
冗長化した会話になるが、各会話毎を見るとどんな内容なのか理解できる

1. <店員>: ご注文どうぞ
2. 【客】: お値打ちセット
3. <店員>: お値打ちセットのバーガー、ドリンクはどれを選択されますか？
4. 【客】: お値打ちセットで、チーズバーガー
5. 【客】: お値打ちセットで、チーズバーガー、ジンジャーエール

前の状態を保存せずに、それぞれの会話が独立して成立する

### ステートレスのメリット

- 単一のリクエスト以外みる必要がないので、監視が容易
- 障害発生したリクエストだけ回復すれば良いので、障害復旧が容易
- リクエスト全体でサーバーリソースを共有する必要がないのでスケールが用意

### ステートレスのデメリット

- 単一のリクエストで完結させるため、リクエストデータに重複がある
- アプリを複数バージョン同時提供し、状態をクライアントに置いておくとアプリ制御が複雑になる

## キャッシュ制御

クライアントはレスポンスをキャッシュできるようにする。

・レスポンスは明示的または暗黙的にキャッシュ可能
・キャッシュを適切に行うことでクライアント／サーバー間の通信が排除されユーザー体験の向上、リソース効率の向上、拡張性の向上が見込める

### キャッシュ制御のメリット

- ユーザー体験の向上
- リソース効率の向上
- 拡張性の向上

### キャッシュ制御のデメリット

- 古いデータを戻してしまうとシステムに対する信頼性の低下につながる

## REST API 設計レベル
- REST API 成熟モデル
- LEVEL 0 : HTTPを使っている
- LEVEL 1 : リソースの概念を導入
- LEVEL 2 : HTTPの動詞を導入
- LEVEL 3 : HATEOASの概念を導入

### LEVEL 0
REST API の基本レベル。RPC（Remote Procedure Cell）スタイルのXML通信

- HTTPは単なる通信手段として利用
- 1URLで全て完結
- リクエストボディーに処理と引数が含まれる

### LEVEL 1

- リソースごとにURLを分離
- HTTPメソッドは活用できていないので、GETかPOSTのみで通信

### LEVEL 2

LEVEL 1 に加えてHTTPメソッドを活用

- リソースに対してHTTPメソッドを使ったCRUD操作が行われている

|操作|CRUD|メソッド|
|:---:|:---:|:---:|
|登録|Create|POST, PUT|
|取得|Read|GET|
|更新|Update|PUT|
|削除|Delete|DELETE|


### LEVEL 3

LEVEL2に加えて、レスポンスにリソース間のつながりが含まれている

